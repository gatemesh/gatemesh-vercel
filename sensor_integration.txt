# Sensor Integration Guide

## Supported Sensors

### Water Level Sensor (I2C Ultrasonic)
- **Model**: Generic I2C ultrasonic or pressure sensor
- **Address**: 0x77 (adjust per datasheet)
- **Pins**: I2C_SDA, I2C_SCL

### Flow Sensor (Pulse-based)
- **Model**: YF-S201 or similar
- **Type**: Hall effect pulse sensor
- **Pin**: GPIO with interrupt support

### Soil Moisture (Capacitive)
- **Model**: Capacitive soil moisture v1.2
- **Type**: Analog output
- **Pin**: ADC-capable GPIO

## Water Level Implementation

### File: `src/modules/irrigation/sensors/WaterLevelSensor.h`

```cpp
#pragma once
#include <Wire.h>

class WaterLevelSensor {
private:
    static constexpr uint8_t SENSOR_ADDR = 0x77;
    static constexpr uint8_t CMD_READ_LEVEL = 0x01;
    float lastLevel = 0.0;
    
public:
    bool init() {
        Wire.begin(I2C_SDA, I2C_SCL);
        Wire.beginTransmission(SENSOR_ADDR);
        if (Wire.endTransmission() != 0) {
            LOG_ERROR("Water level sensor not found\n");
            return false;
        }
        LOG_INFO("Water level sensor initialized\n");
        return true;
    }
    
    float readLevel() {
        Wire.beginTransmission(SENSOR_ADDR);
        Wire.write(CMD_READ_LEVEL);
        Wire.endTransmission();
        
        Wire.requestFrom(SENSOR_ADDR, 4);
        if (Wire.available() >= 4) {
            uint32_t raw = Wire.read() << 24;
            raw |= Wire.read() << 16;
            raw |= Wire.read() << 8;
            raw |= Wire.read();
            
            float level = (raw / 1000.0) * CALIBRATION_FACTOR;
            lastLevel = level;
            return level;
        }
        return -1;
    }
    
    bool checkAlert(float threshold) {
        return lastLevel >= threshold;
    }
};
```

## Flow Sensor Implementation

### File: `src/modules/irrigation/sensors/FlowSensor.h`

```cpp
#pragma once

class FlowSensor {
private:
    static constexpr gpio_num_t FLOW_PIN = GPIO_NUM_10;
    static volatile uint32_t pulseCount;
    static constexpr float CALIBRATION_FACTOR = 7.5; // pulses per liter
    uint32_t lastReadTime = 0;
    float flowRate = 0.0;
    
    static void IRAM_ATTR pulseISR() {
        pulseCount++;
    }
    
public:
    void init() {
        pinMode(FLOW_PIN, INPUT_PULLUP);
        attachInterrupt(digitalPinToInterrupt(FLOW_PIN), pulseISR, FALLING);
        lastReadTime = millis();
        LOG_INFO("Flow sensor initialized\n");
    }
    
    float readFlowRate() {
        uint32_t now = millis();
        uint32_t elapsed = now - lastReadTime;
        
        if (elapsed >= 1000) {
            // Calculate flow rate (L/min)
            flowRate = (pulseCount / CALIBRATION_FACTOR) / (elapsed / 60000.0);
            
            pulseCount = 0;
            lastReadTime = now;
        }
        
        return flowRate;
    }
    
    float getTotalVolume() {
        return pulseCount / CALIBRATION_FACTOR;
    }
};

volatile uint32_t FlowSensor::pulseCount = 0;
```

## Soil Moisture Implementation

### File: `src/modules/irrigation/sensors/MoistureSensor.h`

```cpp
#pragma once

class MoistureSensor {
private:
    static constexpr gpio_num_t MOISTURE_PIN = GPIO_NUM_1;
    static constexpr gpio_num_t POWER_PIN = GPIO_NUM_2;
    
    float dryValue = 2800;  // Calibrate in air
    float wetValue = 1200;  // Calibrate in water
    
public:
    void init() {
        pinMode(POWER_PIN, OUTPUT);
        digitalWrite(POWER_PIN, LOW);
        analogSetAttenuation(ADC_11db);
        LOG_INFO("Moisture sensor initialized\n");
    }
    
    float readMoisture() {
        // Power on sensor
        digitalWrite(POWER_PIN, HIGH);
        delay(100);
        
        // Read multiple samples
        uint32_t sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += analogRead(MOISTURE_PIN);
            delay(10);
        }
        float raw = sum / 10.0;
        
        // Power off to prevent electrolysis
        digitalWrite(POWER_PIN, LOW);
        
        // Convert to percentage
        float moisture = map(raw, dryValue, wetValue, 0, 100);
        return constrain(moisture, 0, 100);
    }
    
    void calibrate(bool isDry) {
        digitalWrite(POWER_PIN, HIGH);
        delay(100);
        
        uint32_t sum = 0;
        for (int i = 0; i < 50; i++) {
            sum += analogRead(MOISTURE_PIN);
            delay(20);
        }
        float value = sum / 50.0;
        
        if (isDry) {
            dryValue = value;
            LOG_INFO("Dry calibration: %.0f\n", dryValue);
        } else {
            wetValue = value;
            LOG_INFO("Wet calibration: %.0f\n", wetValue);
        }
        
        digitalWrite(POWER_PIN, LOW);
    }
};
```

## Auto-Detection Logic

### File: `src/modules/irrigation/SensorDetection.cpp`

```cpp
#include "sensors/WaterLevelSensor.h"
#include "sensors/FlowSensor.h"
#include "sensors/MoistureSensor.h"

Irrigation::NodeType detectSensors() {
    uint32_t capabilities = 0;
    
    // Try I2C water level sensor
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.beginTransmission(0x77);
    if (Wire.endTransmission() == 0) {
        capabilities |= (uint32_t)Irrigation::Capabilities::HAS_LEVEL;
        LOG_INFO("Water level sensor detected\n");
    }
    
    // Try flow sensor (check for pulses)
    pinMode(GPIO_NUM_10, INPUT_PULLUP);
    uint32_t pulses = 0;
    for (int i = 0; i < 100; i++) {
        if (digitalRead(GPIO_NUM_10) == LOW) pulses++;
        delay(1);
    }
    if (pulses > 0) {
        capabilities |= (uint32_t)Irrigation::Capabilities::HAS_FLOW_METER;
        LOG_INFO("Flow sensor detected\n");
    }
    
    // Try moisture sensor (check analog range)
    analogSetAttenuation(ADC_11db);
    int moisture = analogRead(GPIO_NUM_1);
    if (moisture > 100 && moisture < 4000) {
        capabilities |= (uint32_t)Irrigation::Capabilities::HAS_MOISTURE;
        LOG_INFO("Moisture sensor detected\n");
    }
    
    // Determine node type based on capabilities
    if (capabilities & (uint32_t)Irrigation::Capabilities::HAS_LEVEL) {
        return Irrigation::NodeType::WATER_LEVEL_SENSOR;
    }
    else if (capabilities & (uint32_t)Irrigation::Capabilities::HAS_FLOW_METER) {
        return Irrigation::NodeType::FLOW_SENSOR;
    }
    else if (capabilities & (uint32_t)Irrigation::Capabilities::HAS_MOISTURE) {
        return Irrigation::NodeType::SOIL_MOISTURE_SENSOR;
    }
    
    return Irrigation::NodeType::UNDEFINED;
}
```

## Integration in Main Module

### File: `src/modules/irrigation/IrrigationModule.cpp`

```cpp
#include "sensors/WaterLevelSensor.h"
#include "sensors/FlowSensor.h"
#include "sensors/MoistureSensor.h"

void IrrigationModule::initSensors() {
    switch (nodeConfig.type) {
        case Irrigation::NodeType::WATER_LEVEL_SENSOR:
            waterSensor = new WaterLevelSensor();
            waterSensor->init();
            break;
            
        case Irrigation::NodeType::FLOW_SENSOR:
            flowSensor = new FlowSensor();
            flowSensor->init();
            break;
            
        case Irrigation::NodeType::SOIL_MOISTURE_SENSOR:
            moistureSensor = new MoistureSensor();
            moistureSensor->init();
            break;
    }
}

void IrrigationModule::readSensors() {
    if (waterSensor) {
        float level = waterSensor->readLevel();
        sendWaterLevelReport(level);
    }
    
    if (flowSensor) {
        float flow = flowSensor->readFlowRate();
        sendFlowReport(flow);
    }
    
    if (moistureSensor) {
        float moisture = moistureSensor->readMoisture();
        sendMoistureReport(moisture);
    }
}
```

## Calibration Commands

```bash
# Water level sensor
> irrigation calibrate level
Place sensor at known height...
Calibration complete

# Moisture sensor
> irrigation calibrate moisture dry
Place sensor in dry soil...
> irrigation calibrate moisture wet
Place sensor in wet soil...
Calibration complete

# Flow sensor
> irrigation calibrate flow
Run known volume through sensor...
Calibration factor: 7.5 pulses/L
```

## Pin Assignments (XIAO ESP32-S3)

```
GPIO1  (A0) - Soil Moisture Sensor
GPIO2  (A1) - Moisture Power Control
GPIO10 (D8) - Flow Sensor Pulse Input
GPIO43 (SCL) - I2C Clock
GPIO44 (SDA) - I2C Data
```

**Next**: Proceed to `04_FIELD_HIERARCHY.md`
