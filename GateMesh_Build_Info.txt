GateMesh Firmware Build Information
===================================

Build Date: September 28, 2025
Firmware Version: Based on Meshtastic develop branch
Branding: Rebranded to GateMesh

Changes Made:
- Replaced all Meshtastic branding with GateMesh equivalents in graphics code
- Updated boot screen title to "GateMesh"
- Changed help messages and URLs to GateMesh references
- Modified logo and color options to reflect GateMesh branding
- Integrated GateControlModule for smart gate control functionality
- Updated configuration headers with GateMesh app details

Build Status: Successful compilation completed

Further Instructions:
- This file is read-only. Do not edit.
- For deployment, flash the built firmware to GateMesh devices.
- Test gate control features and branding display.
- Refer to GateMesh documentation for additional setup.



# Irrigation System Node Roles Implementation

## Overview
This guide shows how to implement specialized node roles for irrigation control, allowing each device to know its specific function (headgate controller, sensor, pump, valve, etc.)

---

## 1. Define Irrigation Node Types

### 1.1 Create Irrigation Types Enum
```cpp
// src/modules/irrigation/IrrigationTypes.h
#pragma once

namespace Irrigation {

// Primary irrigation node types
enum class NodeType : uint8_t {
    UNDEFINED = 0,
    
    // Controllers (can command other nodes)
    HEADGATE_CONTROLLER = 1,    // Main gate control
    SECTION_CONTROLLER = 2,      // Zone/section control
    PUMP_CONTROLLER = 3,         // Pump station control
    
    // Sensors (report data only)
    WATER_LEVEL_SENSOR = 10,    // Canal/reservoir level
    FLOW_SENSOR = 11,            // Flow rate monitoring
    SOIL_MOISTURE_SENSOR = 12,   // Field moisture
    PRESSURE_SENSOR = 13,        // Line pressure
    WEATHER_STATION = 14,        // Weather data
    
    // Actuators (receive commands)
    GATE_VALVE = 20,             // Simple open/close valve
    VARIABLE_VALVE = 21,         // Variable position valve
    PUMP_RELAY = 22,             // Pump on/off control
    LATERAL_VALVE = 23,          // Lateral line valve
    
    // Hybrid (sensor + actuator)
    SMART_VALVE = 30,            // Valve with flow sensor
    SMART_PUMP = 31,             // Pump with pressure sensor
    PIVOT_CONTROLLER = 32,       // Center pivot irrigation
    
    // Infrastructure
    REPEATER_STATION = 40,       // Signal repeater only
    GATEWAY_STATION = 41,        // Internet/SCADA gateway
    WEATHER_GATEWAY = 42,        // Weather data gateway
    
    // Monitoring
    OBSERVER = 50                // Read-only monitoring node
};

// Node capabilities flags
enum class Capabilities : uint32_t {
    NONE = 0,
    CAN_CONTROL = (1 << 0),         // Can send commands
    CAN_SENSE = (1 << 1),           // Has sensors
    CAN_ACTUATE = (1 << 2),         // Has actuators
    HAS_FLOW_METER = (1 << 3),      // Flow measurement
    HAS_PRESSURE = (1 << 4),        // Pressure sensor
    HAS_MOISTURE = (1 << 5),        // Moisture sensor
    HAS_LEVEL = (1 << 6),           // Level sensor
    HAS_WEATHER = (1 << 7),         // Weather sensors
    HAS_GPS = (1 << 8),             // Position aware
    HAS_SCHEDULE = (1 << 9),        // Autonomous scheduling
    BATTERY_POWERED = (1 << 10),    // Battery vs mains
    SOLAR_POWERED = (1 << 11),      // Solar charging
    HAS_BACKUP = (1 << 12),         // Backup power
    REMOTE_MANAGEABLE = (1 << 13),  // OTA updates
    DATA_LOGGER = (1 << 14),        // SD card logging
    ALARM_CAPABLE = (1 << 15)       // Can trigger alarms
};

// Operating states
enum class State : uint8_t {
    OFFLINE = 0,
    INITIALIZING = 1,
    IDLE = 2,
    ACTIVE = 3,
    IRRIGATING = 4,
    DRAINING = 5,
    ERROR = 6,
    MAINTENANCE = 7,
    EMERGENCY_STOP = 8
};

} // namespace Irrigation
```

### 1.2 Node Configuration Structure
```cpp
// src/modules/irrigation/IrrigationNode.h
#pragma once
#include "IrrigationTypes.h"
#include "configuration.h"

class IrrigationNodeConfig {
public:
    // Identity
    Irrigation::NodeType type = Irrigation::NodeType::UNDEFINED;
    uint32_t zoneId = 0;           // Which irrigation zone
    char locationName[32] = {0};    // Human-readable location
    
    // Position (for mapping)
    double latitude = 0.0;
    double longitude = 0.0;
    uint16_t elevationM = 0;        // Elevation in meters
    
    // Relationships
    uint32_t parentNode = 0;        // Upstream controller
    uint32_t childNodes[8] = {0};   // Downstream devices
    uint8_t childCount = 0;
    
    // Capabilities
    uint32_t capabilities = 0;
    
    // Calibration
    float flowCalibration = 1.0;    // Flow meter K-factor
    float pressureOffset = 0.0;     // Pressure calibration
    float moistureMin = 0.0;        // Dry reading
    float moistureMax = 100.0;      // Wet reading
    
    // Operating parameters
    uint16_t maxFlowGPM = 0;        // Max flow rate
    uint16_t minPressurePSI = 0;    // Min operating pressure
    uint16_t maxPressurePSI = 0;    // Max safe pressure
    uint32_t valveTimeoutMs = 30000; // Valve operation timeout
    
    // Save/Load from NVS
    void save();
    void load();
    void setDefaults(Irrigation::NodeType type);
};
```

---

## 2. Configuration Methods

### 2.1 Via Serial Console
```cpp
// src/modules/irrigation/IrrigationConsole.cpp

void handleIrrigationCommand(const char* cmd) {
    if (strncmp(cmd, "role ", 5) == 0) {
        const char* roleStr = cmd + 5;
        
        if (strcmp(roleStr, "headgate") == 0) {
            setIrrigationRole(Irrigation::NodeType::HEADGATE_CONTROLLER);
            LOG_INFO("Set role to HEADGATE CONTROLLER\n");
        }
        else if (strcmp(roleStr, "water-sensor") == 0) {
            setIrrigationRole(Irrigation::NodeType::WATER_LEVEL_SENSOR);
            LOG_INFO("Set role to WATER LEVEL SENSOR\n");
        }
        else if (strcmp(roleStr, "valve") == 0) {
            setIrrigationRole(Irrigation::NodeType::GATE_VALVE);
            LOG_INFO("Set role to GATE VALVE\n");
        }
        else if (strcmp(roleStr, "pump") == 0) {
            setIrrigationRole(Irrigation::NodeType::PUMP_CONTROLLER);
            LOG_INFO("Set role to PUMP CONTROLLER\n");
        }
        else if (strcmp(roleStr, "moisture") == 0) {
            setIrrigationRole(Irrigation::NodeType::SOIL_MOISTURE_SENSOR);
            LOG_INFO("Set role to SOIL MOISTURE SENSOR\n");
        }
        else if (strcmp(roleStr, "weather") == 0) {
            setIrrigationRole(Irrigation::NodeType::WEATHER_STATION);
            LOG_INFO("Set role to WEATHER STATION\n");
        }
        else {
            LOG_ERROR("Unknown role: %s\n", roleStr);
            LOG_INFO("Available roles:\n");
            LOG_INFO("  headgate    - Main gate controller\n");
            LOG_INFO("  water-sensor - Water level sensor\n");
            LOG_INFO("  valve       - Gate valve actuator\n");
            LOG_INFO("  pump        - Pump controller\n");
            LOG_INFO("  moisture    - Soil moisture sensor\n");
            LOG_INFO("  weather     - Weather station\n");
        }
    }
}

// Console command handler
void setup() {
    // Register commands
    console->registerCommand("irrigation", handleIrrigationCommand);
    
    // Usage:
    // > irrigation role headgate
    // > irrigation zone 5
    // > irrigation parent 0x12345678
}
```

### 2.2 Via Web Interface
```html
<!-- data/static/irrigation_config.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Irrigation Node Configuration</title>
</head>
<body>
    <h1>Configure Irrigation Node</h1>
    
    <form id="nodeConfig">
        <!-- Node Type Selection -->
        <div class="form-group">
            <label>Node Type:</label>
            <select id="nodeType" name="nodeType">
                <optgroup label="Controllers">
                    <option value="1">Headgate Controller</option>
                    <option value="2">Section Controller</option>
                    <option value="3">Pump Controller</option>
                </optgroup>
                <optgroup label="Sensors">
                    <option value="10">Water Level Sensor</option>
                    <option value="11">Flow Sensor</option>
                    <option value="12">Soil Moisture Sensor</option>
                    <option value="13">Pressure Sensor</option>
                    <option value="14">Weather Station</option>
                </optgroup>
                <optgroup label="Actuators">
                    <option value="20">Gate Valve</option>
                    <option value="21">Variable Valve</option>
                    <option value="22">Pump Relay</option>
                    <option value="23">Lateral Valve</option>
                </optgroup>
            </select>
        </div>
        
        <!-- Zone Assignment -->
        <div class="form-group">
            <label>Irrigation Zone:</label>
            <input type="number" id="zoneId" min="0" max="99" value="0">
        </div>
        
        <!-- Location Name -->
        <div class="form-group">
            <label>Location Name:</label>
            <input type="text" id="location" placeholder="e.g., North Field Gate">
        </div>
        
        <!-- GPS Coordinates -->
        <div class="form-group">
            <label>GPS Coordinates:</label>
            <input type="text" id="latitude" placeholder="Latitude">
            <input type="text" id="longitude" placeholder="Longitude">
            <button type="button" onclick="getCurrentLocation()">üìç Use Current</button>
        </div>
        
        <!-- Parent Node (for hierarchy) -->
        <div class="form-group">
            <label>Parent Controller ID:</label>
            <input type="text" id="parentNode" placeholder="0x00000000">
            <button type="button" onclick="scanForControllers()">üîç Scan</button>
        </div>
        
        <!-- Type-specific settings -->
        <div id="typeSpecificSettings"></div>
        
        <button type="submit">Save Configuration</button>
    </form>
    
    <script>
    document.getElementById('nodeType').addEventListener('change', function() {
        showTypeSpecificSettings(this.value);
    });
    
    function showTypeSpecificSettings(type) {
        const settingsDiv = document.getElementById('typeSpecificSettings');
        settingsDiv.innerHTML = '';
        
        switch(parseInt(type)) {
            case 1: // Headgate Controller
                settingsDiv.innerHTML = `
                    <h3>Headgate Settings</h3>
                    <label>Max Flow (GPM):</label>
                    <input type="number" name="maxFlow" value="1000">
                    <label>Gate Travel Time (sec):</label>
                    <input type="number" name="travelTime" value="30">
                `;
                break;
                
            case 10: // Water Level Sensor
                settingsDiv.innerHTML = `
                    <h3>Level Sensor Settings</h3>
                    <label>Sensor Range (ft):</label>
                    <input type="number" name="range" value="10">
                    <label>Alert Level (ft):</label>
                    <input type="number" name="alertLevel" value="8">
                    <label>Critical Level (ft):</label>
                    <input type="number" name="criticalLevel" value="9">
                `;
                break;
                
            case 12: // Soil Moisture
                settingsDiv.innerHTML = `
                    <h3>Moisture Sensor Settings</h3>
                    <label>Dry Reading:</label>
                    <input type="number" name="dryReading" value="0">
                    <label>Wet Reading:</label>
                    <input type="number" name="wetReading" value="1023">
                    <label>Target Moisture (%):</label>
                    <input type="number" name="targetMoisture" value="65">
                `;
                break;
        }
    }
    
    // Submit configuration
    document.getElementById('nodeConfig').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const config = {
            type: document.getElementById('nodeType').value,
            zone: document.getElementById('zoneId').value,
            location: document.getElementById('location').value,
            lat: document.getElementById('latitude').value,
            lon: document.getElementById('longitude').value,
            parent: document.getElementById('parentNode').value
        };
        
        fetch('/api/irrigation/config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(config)
        })
        .then(response => response.json())
        .then(data => {
            alert('Configuration saved! Node will restart.');
            setTimeout(() => location.reload(), 3000);
        });
    });
    </script>
</body>
</html>
```

### 2.3 Via Mobile App Configuration
```kotlin
// Android: IrrigationNodeConfigFragment.kt
@Composable
fun IrrigationNodeConfig(
    viewModel: IrrigationViewModel = hiltViewModel()
) {
    val nodeTypes = remember {
        listOf(
            NodeTypeOption(1, "Headgate Controller", "üö™"),
            NodeTypeOption(10, "Water Level Sensor", "üíß"),
            NodeTypeOption(12, "Soil Moisture Sensor", "üå±"),
            NodeTypeOption(20, "Gate Valve", "üîß"),
            NodeTypeOption(3, "Pump Controller", "‚õΩ"),
            NodeTypeOption(14, "Weather Station", "üå§Ô∏è")
        )
    }
    
    Column(modifier = Modifier.padding(16.dp)) {
        Text(
            "Configure Irrigation Node",
            style = MaterialTheme.typography.headlineMedium
        )
        
        // Visual node type selector
        LazyVerticalGrid(
            columns = GridCells.Fixed(2),
            contentPadding = PaddingValues(8.dp)
        ) {
            items(nodeTypes) { nodeType ->
                NodeTypeCard(
                    nodeType = nodeType,
                    selected = viewModel.selectedType == nodeType.id,
                    onClick = { viewModel.selectNodeType(nodeType.id) }
                )
            }
        }
        
        // Zone selector
        OutlinedTextField(
            value = viewModel.zoneId,
            onValueChange = { viewModel.updateZoneId(it) },
            label = { Text("Irrigation Zone") },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
        )
        
        // Location name
        OutlinedTextField(
            value = viewModel.locationName,
            onValueChange = { viewModel.updateLocationName(it) },
            label = { Text("Location (e.g., North Field Gate)") }
        )
        
        // Parent node selector
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            OutlinedTextField(
                value = viewModel.parentNodeId,
                onValueChange = { viewModel.updateParentNode(it) },
                label = { Text("Parent Controller") },
                modifier = Modifier.weight(1f)
            )
            
            IconButton(onClick = { viewModel.scanForControllers() }) {
                Icon(Icons.Default.Search, "Scan")
            }
        }
        
        // Save button
        Button(
            onClick = { viewModel.saveConfiguration() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save Configuration")
        }
    }
}
```

---

## 3. Protocol Extensions

### 3.1 Add Irrigation Messages to Protobuf
```protobuf
// protobufs/irrigation.proto
syntax = "proto3";
package irrigation;

// Node announcement with role
message IrrigationNodeInfo {
    uint32 node_id = 1;
    NodeType type = 2;
    uint32 zone_id = 3;
    string location = 4;
    double latitude = 5;
    double longitude = 6;
    uint32 parent_node = 7;
    repeated uint32 child_nodes = 8;
    uint32 capabilities = 9;
    State current_state = 10;
}

enum NodeType {
    UNDEFINED = 0;
    HEADGATE_CONTROLLER = 1;
    SECTION_CONTROLLER = 2;
    PUMP_CONTROLLER = 3;
    WATER_LEVEL_SENSOR = 10;
    FLOW_SENSOR = 11;
    SOIL_MOISTURE_SENSOR = 12;
    PRESSURE_SENSOR = 13;
    WEATHER_STATION = 14;
    GATE_VALVE = 20;
    VARIABLE_VALVE = 21;
    PUMP_RELAY = 22;
}

enum State {
    OFFLINE = 0;
    IDLE = 1;
    ACTIVE = 2;
    IRRIGATING = 3;
    ERROR = 4;
}

// Commands between nodes
message IrrigationCommand {
    uint32 target_node = 1;
    oneof command {
        ValveCommand valve = 2;
        PumpCommand pump = 3;
        QueryCommand query = 4;
        ConfigCommand config = 5;
    }
}

message ValveCommand {
    enum Action {
        CLOSE = 0;
        OPEN = 1;
        SET_POSITION = 2;
        STOP = 3;
    }
    Action action = 1;
    uint32 position_percent = 2;  // For variable valves
    uint32 duration_sec = 3;      // Auto-close timer
}
```

---

## 4. Automatic Role Detection

### 4.1 Hardware-Based Auto-Detection
```cpp
// src/modules/irrigation/IrrigationAutoDetect.cpp

Irrigation::NodeType detectNodeType() {
    // Check connected hardware to auto-detect type
    
    // Check for flow sensor
    if (isFlowSensorConnected()) {
        if (hasMotorControl()) {
            return Irrigation::NodeType::SMART_VALVE;
        }
        return Irrigation::NodeType::FLOW_SENSOR;
    }
    
    // Check for water level sensor (ultrasonic/pressure)
    if (isWaterLevelSensorConnected()) {
        return Irrigation::NodeType::WATER_LEVEL_SENSOR;
    }
    
    // Check for soil moisture sensors
    if (isMoistureSensorConnected()) {
        return Irrigation::NodeType::SOIL_MOISTURE_SENSOR;
    }
    
    // Check for valve/motor control
    if (hasMotorControl()) {
        if (hasPositionFeedback()) {
            return Irrigation::NodeType::VARIABLE_VALVE;
        }
        return Irrigation::NodeType::GATE_VALVE;
    }
    
    // Check for weather sensors
    if (isWeatherSensorsConnected()) {
        return Irrigation::NodeType::WEATHER_STATION;
    }
    
    // Default to undefined
    return Irrigation::NodeType::UNDEFINED;
}

bool isFlowSensorConnected() {
    // Check for pulse input on flow sensor pin
    pinMode(FLOW_SENSOR_PIN, INPUT_PULLUP);
    int pulseCount = 0;
    unsigned long startTime = millis();
    
    while (millis() - startTime < 100) {
        if (digitalRead(FLOW_SENSOR_PIN) == LOW) {
            pulseCount++;
            while (digitalRead(FLOW_SENSOR_PIN) == LOW);
        }
    }
    
    return pulseCount > 0;
}
```

---

## 5. Display Role on Screen

### 5.1 OLED Display
```cpp
// src/graphics/Screen.cpp

void Screen::drawIrrigationStatus() {
    display->setTextAlignment(TEXT_ALIGN_LEFT);
    
    // Draw node type icon and name
    const char* typeIcon = getIrrigationIcon(nodeConfig.type);
    const char* typeName = getIrrigationTypeName(nodeConfig.type);
    
    display->setFont(ArialMT_Plain_16);
    display->drawString(0, 0, typeIcon);
    display->drawString(20, 0, typeName);
    
    // Draw zone info
    display->setFont(ArialMT_Plain_10);
    char zoneStr[32];
    snprintf(zoneStr, sizeof(zoneStr), "Zone %d", nodeConfig.zoneId);
    display->drawString(0, 20, zoneStr);
    
    // Draw location
    display->drawString(0, 32, nodeConfig.locationName);
    
    // Draw state
    display->drawString(0, 44, getStateName(currentState));
    
    // Type-specific display
    switch (nodeConfig.type) {
        case Irrigation::NodeType::WATER_LEVEL_SENSOR:
            drawWaterLevel(80, 20);
            break;
            
        case Irrigation::NodeType::GATE_VALVE:
            drawValvePosition(80, 20);
            break;
            
        case Irrigation::NodeType::SOIL_MOISTURE_SENSOR:
            drawMoistureLevel(80, 20);
            break;
    }
}

const char* getIrrigationIcon(Irrigation::NodeType type) {
    switch (type) {
        case Irrigation::NodeType::HEADGATE_CONTROLLER: return "üö™";
        case Irrigation::NodeType::WATER_LEVEL_SENSOR: return "üíß";
        case Irrigation::NodeType::SOIL_MOISTURE_SENSOR: return "üå±";
        case Irrigation::NodeType::GATE_VALVE: return "üîß";
        case Irrigation::NodeType::PUMP_CONTROLLER: return "‚õΩ";
        case Irrigation::NodeType::WEATHER_STATION: return "üå§Ô∏è";
        default: return "‚ùì";
    }
}
```

---

## 6. Hierarchy & Command Authority

### 6.1 Command Permission System
```cpp
// src/modules/irrigation/IrrigationAuth.cpp

bool canNodeCommand(uint32_t sourceNode, uint32_t targetNode) {
    // Get configurations
    auto sourceConfig = getNodeConfig(sourceNode);
    auto targetConfig = getNodeConfig(targetNode);
    
    // Controllers can command their children
    if (sourceConfig.type <= 3) {  // Is controller type
        // Check if target is a child
        for (int i = 0; i < sourceConfig.childCount; i++) {
            if (sourceConfig.childNodes[i] == targetNode) {
                return true;
            }
        }
        
        // Check if same zone
        if (sourceConfig.zoneId == targetConfig.zoneId) {
            // Controller can command actuators in same zone
            if (targetConfig.type >= 20 && targetConfig.type < 30) {
                return true;
            }
        }
    }
    
    // Headgate controller can command anything
    if (sourceConfig.type == Irrigation::NodeType::HEADGATE_CONTROLLER) {
        return true;
    }
    
    // Parent can command children
    if (targetConfig.parentNode == sourceNode) {
        return true;
    }
    
    return false;
}
```

---

## 7. Role-Specific Behaviors

### 7.1 Automatic Behavior Based on Type
```cpp
// src/modules/irrigation/IrrigationBehavior.cpp

void IrrigationModule::setupRoleBehavior() {
    switch (nodeConfig.type) {
        case Irrigation::NodeType::WATER_LEVEL_SENSOR:
            // Report water level every 5 minutes
            setIntervalMillis(300000);
            enableSensor(SENSOR_WATER_LEVEL);
            break;
            
        case Irrigation::NodeType::SOIL_MOISTURE_SENSOR:
            // Report moisture every 15 minutes
            setIntervalMillis(900000);
            enableSensor(SENSOR_MOISTURE);
            // Go to deep sleep between readings
            enableDeepSleep(true);
            break;
            
        case Irrigation::NodeType::HEADGATE_CONTROLLER:
            // Always awake, check for commands
            setIntervalMillis(1000);
            enableDeepSleep(false);
            // Start schedule manager
            scheduleManager.begin();
            break;
            
        case Irrigation::NodeType::GATE_VALVE:
            // Listen for commands, report status on change
            setIntervalMillis(5000);
            enableMotorControl();
            break;
            
        case Irrigation::NodeType::WEATHER_STATION:
            // Report weather every 10 minutes
            setIntervalMillis(600000);
            enableSensor(SENSOR_WEATHER_ALL);
            // Connect to weather services if gateway
            if (hasInternetConnection()) {
                weatherService.connect();
            }
            break;
    }
}
```

---

## 8. Testing Your Role System

### 8.1 Test Commands
```bash
# Set node as headgate controller
> irrigation role headgate
> irrigation zone 1
> irrigation location "Main Canal Gate"

# Set node as water sensor
> irrigation role water-sensor
> irrigation zone 1
> irrigation parent 0x12345678
> irrigation location "Canal Level Monitor"

# Query current role
> irrigation status
Node Type: HEADGATE_CONTROLLER
Zone: 1
Location: Main Canal Gate
State: IDLE
Children: 3 nodes
Capabilities: CAN_CONTROL | HAS_SCHEDULE

# List all nodes and their roles
> irrigation list
ID        Type                Zone  Location
---------------------------------------------
0x1234    HEADGATE_CONTROL    1     Main Canal Gate
0x2345    WATER_LEVEL_SENSOR  1     Canal Monitor
0x3456    GATE_VALVE          1     Field A Inlet
0x4567    MOISTURE_SENSOR     2     Field B Center
```

---

This implementation gives you:

1. **Clear role definition** for each node
2. **Multiple configuration methods** (serial, web, app)
3. **Automatic hardware detection** when possible
4. **Hierarchical command authority**
5. **Role-specific behaviors** and reporting intervals
6. **Visual identification** on screen and app

Each node knows exactly what it is and what it's supposed to do in your irrigation system!